var fs = require('fs');
var crypto = require('crypto');
var AWS = require('aws-sdk');

//TODO: move to config.
var key = 'alias/lockservice';

var configOpt =
{
   credentialProvider: new AWS.CredentialProviderChain(),
   region: 'us-east-1'
};

AWS.config  = new AWS.Config(configOpt);
var kms = new AWS.KMS();
var IVSize = 16;
var cryptoPadSize = 16;

function DeviceEncrypt(userId, lockId) {
    this.lockId = lockId;
    this.userId = userId;
}

// do not alter this, if the format changes than won't be able to 
// retrieve encryption key, the encrypt context is based on this format.
function getKeyFileName(userId, lockId) {
    var userclean = userId.replace('|', '-');
    console.log(userclean);
    var keyName = userclean + '-' + lockId;
    return keyName;
}

function getKeyFilePath(keyName) {
   return './data/keys/' + keyName;
}

function getCiphers(devEnc, callback) {
   var keyFileName=getKeyFileName(devEnc.userId, devEnc.lockId);
   var keyFile = getKeyFilePath(keyFileName);

   console.log('reading key file:', keyFile);
   fs.readFile(keyFile, function(fileerr, buffer) {
       console.log('read key file returned');

      if(fileerr) {
          console.error('failure to read key file:',keyFile);
          callback({error: 'missing key file'});
      } else {

          var params = {
              EncryptionContext: {device: keyFileName },
              CiphertextBlob: buffer
          };
          console.log('decrypting key with params: ', params);

          kms.decrypt(params, function(decryptErr, data) {
              console.log('returned from key decrypt, error: ', decryptErr);
             var keydata = data.Plaintext;

             if(decryptErr) {
                 console.error('decyrpt key error: ', decryptErr, ' keyFileName: ', keyFileName );
                 callback({error: 'Decrpyt key failure'});
             }else {
                 console.log('got encryption key', keydata);
                 crypto.randomBytes(IVSize, function(randerr, iv) {
                     if(randerr) {
                        console.eror('error gen IV: ', randerr );
                        callback({error: 'failed to generate IV'});
                     } else {
                        console.log('creating ciphers');
                        devEnc.cipher = crypto.createCipheriv('aes-128-cbc', keydata, iv);
                        devEnc.decipher = crypto.createDecipher('aes-128-cbc', keydata, iv);
                        callback(null);
                     }
                 });
             }
         });
      }
   });
}

function encryptStrData(devEncrypt, strData, callback) {
    var encodedStrLen = Buffer.byteLength(strData, 'utf-8');
    var bufLen = encodedStrLen + cryptoPadSize;
    var cipher = devEncrypt.cipher;
    var data = new Buffer(bufLen);

    //using Explicit Initialization Vector, first block will be garbled.
    data.fill(0,0,cryptoPadSize);
    data.write(strData, cryptoPadSize);
    console.log('buffer size: ', data.length);

    var encrypted = cipher.update(data);
    var encrypted += cipher.final();
    console.log('encrypt size; ', encryptBuf.length);

    callback(null, encryptBuf);
}

function decryptBuffer(devEncrypt, buffer, callback) {
    var decrypted = devEncrypt.decipher.update(buffer);
    var decrypted += devEncrypt.decipher.final();
    
    console.log('deciphered buffer: ', decrypted);

    //using Explicit Initialization Vector, first block will be garbled.
    var data = decrypted.toString('utf-8', cryptoPadSize);
    console.log('string data: ', data);
    callback(null, data);
}


DeviceEncrypt.prototype.encrypt = function(string, callback) {
    var self = this;
    
    if(self.cipher === undefined) {
        console.log('getting ciphers');

        getCiphers(self, function(cipherErr) {
            if(cipherErr) {
                console.error('err getting cipher', cipherErr);
                callback(cipherErr);
            }else{
                console.log('got cipher, encrypting');
                encryptStrData(self,string, callback);
            }
        });
   }else {
       encryptStrData(string, callback);
   }
};

DeviceEncrypt.prototype.decrypt = function(buffer, callback) {
    var self = this;
    
    if(self.decipher === undefined) {
        getCiphers(self, function(cipherErr) {
            if(cipherErr) {
                callback(cipherErr);
            }else{
                decryptBuffer(self, buffer, callback);
            }
        });
   }else {
       decryptBuffer(self, string, callback);
   }
};



DeviceEncrypt.prototype.generateLockKey = function(callback) {
    var self = this;

     var keyFileName = getKeyFileName(self.userId, self.lockId);

    var keyParams = {
        KeyId: key,
        EncryptionContext: { device: keyFileName },
        KeySpec: 'AES_128'
    };

    console.log('calling kms.generateDataKey');

    kms.generateDataKey(keyParams, function(keyerr, keydata) {
        if(keyerr) {
            console.log('error generating key:' + keyerr);
            console.log('stack: ' + keyerr.stack);
            callback(false, null);
        } else {
            console.info('obtained data key, saving to file'), keydata;
            var keyFile = getKeyFilePath(keyFileName);
            fs.writeFile(keyFile, keydata.CiphertextBlob, function(fileerr){
                if(fileerr) {
                    console.log('error saving key: ' + fileerr);
                    console.log('stack: ' + fileerr.stack);
                    callback(filerr);
                } else {
                    callback(null, keydata.Plaintext);
                }
            });
        }
    });
};

DeviceEncrypt.prototype.removeLockKey = function(callback) {
    var self = this;
    var keyFileName = getKeyFileName(self.userId, self.lockId);
    var keyFile = getKeyFilePath(keyFileName);
    fs.unlink(keyFile, function(deleteErr) {
       if(deleteErr) console.log('key file deletion error: ', deleteErr);
    });
};

module.exports = DeviceEncrypt;
